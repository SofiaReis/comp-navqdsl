/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. NavqParser.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(NavqParser)package parser;import java.io.*;import java.util.Hashtable;import java.util.Enumeration;import org.jgrapht.*;import org.jgrapht.alg.*;import org.jgrapht.graph.*;import java.util.List;import java.util.ArrayList;import java.util.regex.Matcher;import org.jgrapht.traverse.*;import java.util.Collections;import java.net.*;public class NavqParser/*@bgen(jjtree)*/implements NavqParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTNavqParserState jjtree = new JJTNavqParserState();

/*@egen*/  public static Hashtable ST = new Hashtable();  public static String missedDouble = "";  public static Hashtable getHashTable()  {    return ST;  }  public void PrintWarnings()  {    if (missedDouble != "") System.out.println("Warning: You've missed doublepoint, in the following situation " + missedDouble);  }}PARSER_END(NavqParser)SKIP :{  " "| "\r"| "\t"}//Static Tokens
TOKEN :{  < NUMBER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >| < CRITERIA_TYPE :    "shortest"  | "fastest" >| < QUOTED :    "\""    (      "\\" ~[ ] //any escaped character
    | //or
      ~[ "\"", "\\" ] //any character except quote or backslash
    )*    "\"" >| < DOUBLEPOINT : ":" >| < LF : "\n" >}//Reserved Words
TOKEN :{  < OUTPUT : "Output" >| < PATHS : "paths" >| < PLACES : "places" >| < FROM : "from" >| < TO : "to" >| < CRITERIA : "criteria" >| < WITH : "with" >| < DISTANCE : "distance" >}//Operators
TOKEN :{  < COMPARE :    "<="  | ">="  | "="  | "<"  | ">" >}SimpleNode Start() :{/*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Start */
  try {
/*@egen*/  output()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void output() :{/*@bgen(jjtree) output */
  SimpleNode jjtn000 = new SimpleNode(JJTOUTPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) output */
  try {
/*@egen*/  try  {    < OUTPUT >  }  catch (TokenMgrError e)  {    System.out.println("ERROR: You Should use the next queries:");    System.out.println("       Output <number> paths from \"<startVertexID>\" to \"<endVertexID>\": criteria: <shortest/fastest>");    System.out.println("       Output places with distance <compareSign> <number> places from \"<startVertexID>\"");    System.exit(0);  }  catch (ParseException e)  {    System.out.println("PARSER ERROR: OUTPUT missing.");    System.exit(0);  }  try  {    (numberOfPaths()  | placesAtDistance())  }  catch (TokenMgrError e)  {    System.out.println("ERROR: You failed choosing the query:");    System.out.println("       Output");    System.out.println("              [<number> paths from \"<startVertexID>\" to \"<endVertexID>\": criteria: <shortest/fastest>]");    System.out.println("       OR   ");    System.out.println("              [places with distance <compareSign> <number> places from \"<startVertexID>\"]");    System.exit(0);  }  < LF >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void numberOfPaths() :{/*@bgen(jjtree) numberOfPaths */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMBEROFPATHS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2 = null;}{/*@bgen(jjtree) numberOfPaths */
  try {
/*@egen*/  number()  try  {    < PATHS >  }  catch (ParseException e)  {    System.out.println("PARSER ERROR: < paths > missing.");    System.exit(0);  }  try  {    < FROM >  }  catch (ParseException e)  {    System.out.println("PARSER ERROR: < from > missing.");    System.exit(0);  }  places()  (    (      t1 = < DOUBLEPOINT > try      {        < CRITERIA >      }      catch (ParseException e)      {        System.out.println("PARSER ERROR: < criteria > missing.");        System.exit(0);      }    )  | t1 = < CRITERIA >  )  {    if (t1.image != ":")    {      missedDouble += " < : criteria > ";    }  }  (    (      t2 = < DOUBLEPOINT > criteriaType()    )  | criteriaType()  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    try    {      if (t2.image != ":")      {        missedDouble += " <  criteria: > ";      }    }    catch (NullPointerException e)    {      missedDouble += " <  criteria: > ";    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void placesAtDistance() :{/*@bgen(jjtree) placesAtDistance */
  SimpleNode jjtn000 = new SimpleNode(JJTPLACESATDISTANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) placesAtDistance */
  try {
/*@egen*/
  try  {      < PLACES > }
  catch (ParseException e)
  {
    System.out.println("PARSER ERROR: < places > missing.");
    System.exit(0);
  }
  try  {    < WITH > }
  catch (ParseException e)
  {
    System.out.println("PARSER ERROR: < with > missing.");
    System.exit(0);
  }
  try  {    < DISTANCE > }
  catch (ParseException e)
  {
    System.out.println("PARSER ERROR: < distance > missing.");
    System.exit(0);
  }compareSign() number()
  try  {    < PLACES > }
  catch (ParseException e)
  {
    System.out.println("PARSER ERROR: < places > missing.");
    System.exit(0);
  }
  try  {    < FROM > }
  catch (ParseException e)
  {
    System.out.println("PARSER ERROR: < from > missing.");
    System.exit(0);
  }place()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void compareSign() :{/*@bgen(jjtree) compareSign */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPARESIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) compareSign */
  try {
/*@egen*/  try  {    t = < COMPARE >    {      jjtn000.value = t.image;      //System.out.println(t.image);
      ST.put(t.image, new STC("compare", t.image));    }  }  catch (TokenMgrError e)  {    System.out.println("ERROR: Invalid compare sign!");    System.exit(0);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void places() :{/*@bgen(jjtree) places */
  SimpleNode jjtn000 = new SimpleNode(JJTPLACES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) places */
  try {
/*@egen*/  try  {    place()  }  catch (TokenMgrError e)  {    System.out.println("ERROR: Invalid departure place. Should be in format \"[place]\"!");    System.exit(0);  }  try  {    < TO >  }  catch (ParseException e)  {    System.out.println("PARSER ERROR: < to > missing.");    System.exit(0);  }  try  {    place()  }  catch (TokenMgrError e)  {    System.out.println("ERROR: Invalid arrival place. Should be in format \"[place]\"!");    System.exit(0);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void place() :{/*@bgen(jjtree) place */
  SimpleNode jjtn000 = new SimpleNode(JJTPLACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) place */
  try {
/*@egen*/
  try  {      (    t = < QUOTED >  {    jjtn000.value = t.image;    //	System.out.println(t.image);
    ST.put(t.image, new STC("place", t.image));  }
  )}
    catch (ParseException e)
  {
    System.out.println("PARSER ERROR: Place to evaluate missing. E.g. \"1\"");
    System.exit(0);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void number() :{/*@bgen(jjtree) number */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) number */
  try {
/*@egen*/  try  {    (    t = < NUMBER >    {      jjtn000.value = t.image;      //System.out.println(t.image);
      ST.put(t.image, new STC("number", t.image));    }    )
    }  catch (ParseException e)  {    System.out.println("PARSER ERROR: Number missing. Waiting for an Integer!");    System.exit(0);  }  catch (TokenMgrError e)  {    System.out.println("TOKEN ERROR: Invalid number. Waiting for an Integer!");    System.exit(0);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void criteriaType() :{/*@bgen(jjtree) criteriaType */
  SimpleNode jjtn000 = new SimpleNode(JJTCRITERIATYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) criteriaType */
  try {
/*@egen*/  try  {    (t = < CRITERIA_TYPE >    {      jjtn000.value = t.image;      //System.out.println(t.image);
      ST.put(t.image, new STC("criteria_type", t.image));    }    )  }  catch (TokenMgrError e)  {    System.out.println("TOKEN ERROR: Invalid criteria type. Waiting for criteria:shortest or fastest!");    System.exit(0);  }  catch (ParseException e)  {    System.out.println("PARSER ERROR: Criteria type missing. Waiting for criteria:shortest or fastest!");    System.exit(0);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}