/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. NavqParser.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(NavqParser)package parser;

import java.io.*;
import java.util.Hashtable;
import java.util.Enumeration;

 import org.jgrapht.*;
    import org.jgrapht.alg.*;
    import org.jgrapht.graph.*;
    import java.util.List;
import java.util.ArrayList;
import java.util.regex.Matcher;
import org.jgrapht.traverse.*;
import java.util.Collections;


import java.net.*;


public class NavqParser/*@bgen(jjtree)*/implements NavqParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTNavqParserState jjtree = new JJTNavqParserState();

/*@egen*/
	public static Hashtable ST = new Hashtable();
	public static String missedDouble = "";

	public static Hashtable getHashTable()
	{
	  return ST;	}

public void PrintWarnings()
  {
    System.out.println("WARNING: You are beautiful!");
    if(missedDouble!= "")
    	System.out.println("Warning: You've missed doublepoint, in the following situation " + missedDouble);
    
  }
}




PARSER_END(NavqParser)SKIP :{  " "| "\r"| "\t"| "\n"}
//static tokensTOKEN :{ < NUMBER: (<DIGIT>)+>
|  <#DIGIT: ["0"-"9"]>
| < CRITERIA_TYPE: "shortest" | "fastest" >
| <QUOTED: 
    "\"" 
    (
         "\\" ~[]     //any escaped character
    |                 //or
        ~["\"","\\"]  //any character except quote or backslash
    )* 
    "\"" > 
| < DOUBLEPOINT: ":" >
| < CENAS: "\"" >}

//reserved words
TOKEN :
{< OUTPUT: "Output" >
| < PATHS: "paths" >
| < PLACES: "places" >
| < FROM: "from" >
| < TO: "to" >
| < CRITERIA: "criteria" >
| < WITH: "with" >
| < DISTANCE: "distance" >
}

//OPERATORS
TOKEN :
{	< COMPARE: "<=" | ">=" | "=" | "<" | ">" >
}

SimpleNode  Start():
{/*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  
}
{/*@bgen(jjtree) Start */
try {
/*@egen*/
output()/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void output():{/*@bgen(jjtree) output */
  SimpleNode jjtn000 = new SimpleNode(JJTOUTPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
 }
{/*@bgen(jjtree) output */
   try {
/*@egen*/
   
   < OUTPUT >try{  
   (
     numberOfPaths()

   | placesAtDistance())
}
		catch( TokenMgrError e ) {
			System.out.println("There was an ERROR in the QUERIE! \nWaiting for querie Output\n  [number] paths from \"[place]\" to \"[place]\": criteria: [shortest|fastest]\n  places with distance [compare_sign] [number] places from \"[place]\"");
			System.exit( 0 );
			}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


JAVACODE
void error_skipto(int kind) {/*@bgen(jjtree) error_skipto */
SimpleNode jjtn000 = new SimpleNode(JJTERROR_SKIPTO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != 5);
  System.out.println(t.kind + " " + t.image);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
  

    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}


void numberOfPaths():{/*@bgen(jjtree) numberOfPaths */
        SimpleNode jjtn000 = new SimpleNode(JJTNUMBEROFPATHS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t1, t2 =null;
	}
{/*@bgen(jjtree) numberOfPaths */
    try {
/*@egen*/
    number()   <PATHS ><FROM >places()
   			((t1=<DOUBLEPOINT ><CRITERIA > )|t1=<CRITERIA >)   			{
   			  if(t1.image!=":")   			  {
   			    missedDouble+=" [: criteria] ";   			  }   			}

   			  ((t2=<DOUBLEPOINT > criteriaType())|criteriaType())/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/
   			  {
   			  try   			  {   			    
   			  if(t2.image!=":")
   			  {
   			    missedDouble+=" [ criteria:] ";
   			  }   			}   			catch (NullPointerException e) {
    missedDouble+=" [ criteria:] ";
} 
   			}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
  }

  

void placesAtDistance():
{/*@bgen(jjtree) placesAtDistance */
  SimpleNode jjtn000 = new SimpleNode(JJTPLACESATDISTANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  
}
{/*@bgen(jjtree) placesAtDistance */
try {
/*@egen*/
< PLACES ><WITH ><DISTANCE > compareSign() number()<PLACES ><FROM >place()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
  
}
void compareSign():
{/*@bgen(jjtree) compareSign */
   SimpleNode jjtn000 = new SimpleNode(JJTCOMPARESIGN);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) compareSign */
try {
/*@egen*/
try{  
 t=<COMPARE >{jjtn000.value = t.image;
 //System.out.println(t.image);
	ST.put(t.image,new STC("compare_sign",t.image));
}}
	catch( TokenMgrError e ) {
		System.out.println("ERROR: Invalid compare sign!");
		System.exit( 0 );
	}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}
 
void places():
{/*@bgen(jjtree) places */
  SimpleNode jjtn000 = new SimpleNode(JJTPLACES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) places */
try {
/*@egen*/
try
{
  place()
}
	catch( TokenMgrError e ) {
		System.out.println("ERROR: Invalid departure place. Should be in format \"[place]\"!");
		System.exit( 0 );
	}

  <TO >

try{  place()
}
	catch( TokenMgrError e ) {
		System.out.println("ERROR: Invalid arrival place. Should be in format \"[place]\"!");
		System.exit( 0 );
	}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
  }
void place():
{/*@bgen(jjtree) place */
   SimpleNode jjtn000 = new SimpleNode(JJTPLACE);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) place */
 try {
/*@egen*/
 t=< QUOTED>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/  {jjtn000.value = t.image;
 //System.out.println(t.image);
 	ST.put(t.image,new STC("place",t.image));
 }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void number():{/*@bgen(jjtree) number */
   SimpleNode jjtn000 = new SimpleNode(JJTNUMBER);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;}{/*@bgen(jjtree) number */
  try {
/*@egen*/
  try  {    
 t=< NUMBER>  {jjtn000.value = t.image;
 	//System.out.println(t.image);
	ST.put(t.image,new STC("number",t.image));
	
}
}
	catch( TokenMgrError e ) {
		System.out.println("ERROR: Invalid number. Waiting for an Integer!");
		System.exit( 0 );
	}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void  criteriaType():
{/*@bgen(jjtree) criteriaType */
  SimpleNode jjtn000 = new SimpleNode(JJTCRITERIATYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
  
{/*@bgen(jjtree) criteriaType */
  try {
/*@egen*/
  try  {    
  (
	t=<CRITERIA_TYPE >
{jjtn000.value = t.image;
	//System.out.println(t.image);
   ST.put(t.image,new STC("criteria",t.image));
 }

)
}
	catch( TokenMgrError e ) {
		System.out.println("ERROR: Invalid criteria type. Waiting for criteria:shortest or fastest!");
		System.exit( 0 );
	}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}