/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(NavqParser)package parser;

import java.io.*;
import java.util.Hashtable;
import java.util.Enumeration;

 import org.jgrapht.*;
    import org.jgrapht.alg.*;
    import org.jgrapht.graph.*;
    import java.util.List;
    import org.jgrapht.traverse.DepthFirstIterator;
import org.jgrapht.traverse.GraphIterator;
import java.util.ArrayList;
import java.util.regex.Matcher;


import java.net.*;

public class NavqParser{
	public static Hashtable ST = new Hashtable();
	public static SimpleDirectedWeightedGraph<String, DefaultWeightedEdge>  graph = new SimpleDirectedWeightedGraph<String, DefaultWeightedEdge>(DefaultWeightedEdge.class); ;
	
    public static void main(String args []) throws ParseException  {
	String temp;
    STC    temp2;
    NavqParser parser = new NavqParser(System.in);
    SimpleNode root = parser.Start();
    root.dump("");

	 Enumeration t = ST.keys();
	 
	
   	while (t.hasMoreElements() == true) {

          temp = (String)t.nextElement();
          temp2 = (STC)ST.get(temp);
          System.out.println(temp);
          
          if ( temp2.type != null )
            System.out.println(" type = " + temp2.type);
          if ( temp2.value != null )
            System.out.println(" value = " + temp2.value);

    }
          readFile();
          getShortestPaths(graph, "1","4",2);  }

  public static void getShortestPaths(SimpleDirectedWeightedGraph<String, DefaultWeightedEdge>  graph, String startVertice, String endVertice, int numberPaths)  {
     KShortestPaths kgraph = new KShortestPaths(graph, startVertice, numberPaths);
     List shortest_paths = kgraph.getPaths(endVertice);

     for(int i = 0; i < shortest_paths.size(); i++)
     {
     	System.out.println(shortest_paths.get(i));
     }
  }

  public static void readFile()
  {
    try
    {
	    BufferedReader reader = new BufferedReader(new FileReader("./data/small.NY.gr"));
	    String line;
	    while ((line = reader.readLine()) != null)
	    {
	   	   if(line.substring(0, 1).matches("^a.*"))
	   	   {
	   	     addInfoToGraph(line);	   	   }
	   	   
	    }
	    reader.close();
	  }
	  catch (Exception e)
	  {
	    System.err.format("Exception occurred trying to read '%s'.", "./data/small.NY.gr");
	    e.printStackTrace();
	  }
  }

  public static void addInfoToGraph(String str)
  {
	String[] splited = str.split(" ");

	addVertex(splited[1]);
	addVertex(splited[2]);
	
	  DefaultWeightedEdge edge = graph.addEdge(splited[1], splited[2]);
		//System.out.println("NODE1:" + splited[1] + "NODE2:" + splited[2] + "NODE3:" + splited[3]);
    	graph.setEdgeWeight(edge, Integer.parseInt(splited[3]));	
	  }

  public static void addVertex(String vertex)
 {
   if(!graph.containsVertex(vertex))
   {
     graph.addVertex(vertex);   }
  }

  public static void getFastestPaths(SimpleDirectedWeightedGraph<String, DefaultWeightedEdge>  graph, String startVertice, String endVertice, int numberPaths)
  {
     DepthFirstIterator iterator = new DepthFirstIterator(graph, startVertice);
        while(iterator.hasNext()) { 
            System.out.println(iterator.next());
        }

  }


  


 }

PARSER_END(NavqParser)SKIP :{  " "| "\r"| "\t"| "\n"}
//static tokensTOKEN :{ < NUMBER: (<DIGIT>)+>
|  <#DIGIT: ["0"-"9"]>
| < CRITERIA_TYPE: "shortest" | "fastest" >
| <QUOTED: 
    "\"" 
    (
         "\\" ~[]     //any escaped character
    |                 //or
        ~["\"","\\"]  //any character except quote or backslash
    )* 
    "\"" > 
| < DOUBLEPOINT: ":" >
| < CENAS: "\"" >}

//reserved words
TOKEN :
{< OUTPUT: "Output" >
| < PATHS: "paths" >
| < PLACES: "places" >
| < FROM: "from" >
| < TO: "to" >
| < CRITERIA: "criteria" >
| < WITH: "with" >
| < DISTANCE: "distance" >
}

//OPERATORS
TOKEN :
{	< COMPARE: "<=" | ">=" | "=" | "<" | ">" >
}SimpleNode  Start() #START:
{
  
}
{
output() {return jjtThis;}
}

void output() #OUTPUT :{
 }
{ < OUTPUT > (numberOfPaths() | placesAtDistance())}
	
void numberOfPaths()#NUMBER_OF_PATHS:{
 }
{
number() <PATHS ><FROM >places()<DOUBLEPOINT ><CRITERIA ><DOUBLEPOINT > criteriaType()
  }

void placesAtDistance() #PLACES_AT_DISTANCE:
{
  
}
{
< PLACES ><WITH ><DISTANCE > compareSign() number()<PLACES ><FROM >place()
  
}
void compareSign() #COMPARE_SIGN:
{
   Token t;
}
{
 t=<COMPARE >{jjtThis.value = t.image;
 ST.put(t.image,new STC("compare_sign",t.image));}
}
 
void places() #TO:
{}{
  place() <TO >place()}
void place() #PLACE :
{
   Token t;
}
{
 t=< QUOTED>  {jjtThis.value = t.image;
 ST.put(t.image,new STC("place",t.image));}
}

void number() #NUMBER:{
   Token t;}{
 t=< NUMBER>  {jjtThis.value = t.image;
	ST.put(t.image,new STC("number",t.image));
 }}

void  criteriaType() #CRITERIA_TYPE:
{
  Token t;
}
{
t=<CRITERIA_TYPE >  {jjtThis.value = t.image;
   ST.put(t.image,new STC("criteria",t.image));
}
}